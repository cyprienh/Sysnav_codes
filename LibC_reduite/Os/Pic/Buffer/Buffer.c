///////////////////////////////////////////////////////////////////////////////////////////////////
///  @file		Buffer.c
///  
///  @brief		Buffer circulaire sans Ã©crasement
///  
///  @date		05/05/2023
///  @author	Cyprien Heusse
///  @copyright	N/A
///////////////////////////////////////////////////////////////////////////////////////////////////



#include "Buffer.h"
#include <Os/Os.h>


///////////////////////////////////////////////////////////////////////////////////////////////////
// BUFFER init the circular buffer
///////////////////////////////////////////////////////////////////////////////////////////////////
void init_buffer(circular_buffer_t* c_buffer) {
    c_buffer->first = 0;
    c_buffer->last = 0;
    c_buffer->full = 0;
    c_buffer->empty = 1;
}//init_buffer


///////////////////////////////////////////////////////////////////////////////////////////////////
// BUFFER pushes a new element at the end of the buffer
///////////////////////////////////////////////////////////////////////////////////////////////////
void push_element(circular_buffer_t* c_buffer, uint8 element) {
    if(!is_buffer_full(c_buffer)) {
        // An element can be added without overwriting
        c_buffer->buffer[c_buffer->last++] = element;
        if(c_buffer->last == BUFFER_SIZE)
            c_buffer->last = 0; // loop to 0
        if(c_buffer->last == c_buffer->first)
            c_buffer->full = 1;
        c_buffer->empty = 0;
    }
}//push_element


///////////////////////////////////////////////////////////////////////////////////////////////////
// BUFFER removes and returns the oldest element
///////////////////////////////////////////////////////////////////////////////////////////////////
uint8 pop_element(circular_buffer_t* c_buffer) {
    if(!is_buffer_empty(c_buffer)) {
        // There is at least one element to pop
        c_buffer->buffer[c_buffer->first++] = 0;
        if(c_buffer->first == BUFFER_SIZE)
            c_buffer->first = 0; // loop to 0
        if(c_buffer->first == c_buffer->last)
            c_buffer->empty = 1;
        c_buffer->full = 0;
        return 0;
    }
    return 0;
}//pop_element


///////////////////////////////////////////////////////////////////////////////////////////////////
// BUFFER returns boolean indicating if buffer is full
///////////////////////////////////////////////////////////////////////////////////////////////////
char is_buffer_full(circular_buffer_t* c_buffer) {
    return c_buffer->full;
}//is_buffer_full


///////////////////////////////////////////////////////////////////////////////////////////////////
// BUFFER returns boolean indicating if buffer is empty
///////////////////////////////////////////////////////////////////////////////////////////////////
char is_buffer_empty(circular_buffer_t* c_buffer) {
    return c_buffer->empty;
}//is_buffer_empty